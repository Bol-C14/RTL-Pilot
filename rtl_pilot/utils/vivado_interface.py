"""
Vivado Interface Module

Provides utilities for interfacing with Vivado through TCL commands,
subprocess execution, and project management.
"""

import subprocess
import logging
import os
import re
from pathlib import Path
from typing import List, Dict, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum
import asyncio
import tempfile

logger = logging.getLogger(__name__)


class VivadoMode(Enum):
    """Vivado execution modes"""
    GUI = "gui"
    BATCH = "batch" 
    TCL = "tcl"


@dataclass
class VivadoResult:
    """Result from Vivado command execution"""
    success: bool
    stdout: str
    stderr: str
    return_code: int
    execution_time: float


class TCLCommand:
    """Represents a TCL command for Vivado"""
    
    def __init__(self, command: str, description: str = ""):
        """Initialize TCL command"""
        self.command = command
        self.description = description
    
    def __str__(self) -> str:
        """String representation of the command"""
        return self.command
    
    def with_args(self, **kwargs) -> 'TCLCommand':
        """Create a new command with formatted arguments"""
        formatted_command = self.command.format(**kwargs)
        return TCLCommand(formatted_command, self.description)


class TCLScript:
    """Manages a collection of TCL commands"""
    
    def __init__(self, name: str = "script"):
        """Initialize TCL script"""
        self.name = name
        self.commands: List[TCLCommand] = []
        self.variables: Dict[str, str] = {}
    
    def add_command(self, command: Union[str, TCLCommand], 
                   description: str = "") -> 'TCLScript':
        """Add a command to the script"""
        if isinstance(command, str):
            command = TCLCommand(command, description)
        self.commands.append(command)
        return self
    
    def add_variable(self, name: str, value: str) -> 'TCLScript':
        """Add a variable assignment"""
        self.variables[name] = value
        return self
    
    def generate_script(self) -> str:
        """Generate the complete TCL script"""
        script_lines = []
        
        # Add header comment
        script_lines.append(f"# {self.name}")
        script_lines.append(f"# Generated by RTL-Pilot")
        script_lines.append("")
        
        # Add variable assignments
        for var_name, var_value in self.variables.items():
            script_lines.append(f"set {var_name} \"{var_value}\"")
        
        if self.variables:
            script_lines.append("")
        
        # Add commands
        for cmd in self.commands:
            if cmd.description:
                script_lines.append(f"# {cmd.description}")
            script_lines.append(str(cmd))
            script_lines.append("")
        
        return "\n".join(script_lines)
    
    def save_to_file(self, file_path: Union[str, Path]) -> Path:
        """Save script to a file"""
        script_path = Path(file_path)
        script_content = self.generate_script()
        
        try:
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(script_content)
            logger.info(f"TCL script saved: {script_path}")
            return script_path
        except Exception as e:
            logger.error(f"Failed to save TCL script to {script_path}: {e}")
            raise


class VivadoInterface:
    """Interface for executing Vivado commands and managing projects"""
    
    def __init__(self, vivado_path: Optional[str] = None, 
                 working_dir: Optional[str] = None):
        """Initialize Vivado interface"""
        self.vivado_path = vivado_path or self._find_vivado()
        self.working_dir = Path(working_dir) if working_dir else Path.cwd()
        self.working_dir.mkdir(parents=True, exist_ok=True)
        
        if not self.vivado_path:
            raise RuntimeError("Vivado installation not found")
        
        logger.info(f"Vivado interface initialized: {self.vivado_path}")
    
    def _find_vivado(self) -> Optional[str]:
        """Try to find Vivado installation"""
        # Common Vivado installation paths
        common_paths = [
            "/tools/Xilinx/Vivado/*/bin/vivado",
            "/opt/Xilinx/Vivado/*/bin/vivado",
            "C:/Xilinx/Vivado/*/bin/vivado.bat"
        ]
        
        # Check environment variable
        vivado_env = os.environ.get('VIVADO_PATH')
        if vivado_env and Path(vivado_env).exists():
            return vivado_env
        
        # Check common paths
        import glob
        for pattern in common_paths:
            matches = glob.glob(pattern)
            if matches:
                # Return the latest version (assuming sorted order)
                return sorted(matches)[-1]
        
        # Check PATH
        try:
            result = subprocess.run(['which', 'vivado'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except:
            pass
        
        return None
    
    def run_command(self, tcl_command: str, mode: VivadoMode = VivadoMode.BATCH,
                   timeout: Optional[int] = None) -> VivadoResult:
        """Run a single TCL command in Vivado"""
        import time
        start_time = time.time()
        
        try:
            # Prepare command
            cmd_args = [self.vivado_path]
            
            if mode == VivadoMode.BATCH:
                cmd_args.extend(['-mode', 'batch'])
            elif mode == VivadoMode.TCL:
                cmd_args.extend(['-mode', 'tcl'])
            
            cmd_args.extend(['-source', '-'])  # Read from stdin
            
            # Execute command
            process = subprocess.run(
                cmd_args,
                input=tcl_command,
                text=True,
                capture_output=True,
                cwd=self.working_dir,
                timeout=timeout
            )
            
            execution_time = time.time() - start_time
            
            result = VivadoResult(
                success=process.returncode == 0,
                stdout=process.stdout,
                stderr=process.stderr,
                return_code=process.returncode,
                execution_time=execution_time
            )
            
            if result.success:
                logger.info(f"Vivado command executed successfully in {execution_time:.2f}s")
            else:
                logger.error(f"Vivado command failed: {result.stderr}")
            
            return result
            
        except subprocess.TimeoutExpired:
            logger.error(f"Vivado command timed out after {timeout}s")
            return VivadoResult(False, "", "Command timed out", -1, time.time() - start_time)
        except Exception as e:
            logger.error(f"Error executing Vivado command: {e}")
            return VivadoResult(False, "", str(e), -1, time.time() - start_time)
    
    def run_script(self, script: Union[TCLScript, str, Path], 
                   mode: VivadoMode = VivadoMode.BATCH,
                   timeout: Optional[int] = None) -> VivadoResult:
        """Run a TCL script in Vivado"""
        if isinstance(script, TCLScript):
            # Create temporary file for the script
            with tempfile.NamedTemporaryFile(mode='w', suffix='.tcl', 
                                           delete=False) as f:
                f.write(script.generate_script())
                script_path = f.name
        elif isinstance(script, (str, Path)):
            script_path = str(script)
        else:
            raise ValueError("Script must be TCLScript, string, or Path")
        
        try:
            # Prepare command
            cmd_args = [self.vivado_path]
            
            if mode == VivadoMode.BATCH:
                cmd_args.extend(['-mode', 'batch'])
            elif mode == VivadoMode.TCL:
                cmd_args.extend(['-mode', 'tcl'])
            
            cmd_args.extend(['-source', script_path])
            
            # Execute script
            import time
            start_time = time.time()
            
            process = subprocess.run(
                cmd_args,
                capture_output=True,
                text=True,
                cwd=self.working_dir,
                timeout=timeout
            )
            
            execution_time = time.time() - start_time
            
            result = VivadoResult(
                success=process.returncode == 0,
                stdout=process.stdout,
                stderr=process.stderr,
                return_code=process.returncode,
                execution_time=execution_time
            )
            
            if result.success:
                logger.info(f"Vivado script executed successfully in {execution_time:.2f}s")
            else:
                logger.error(f"Vivado script failed: {result.stderr}")
            
            return result
            
        except subprocess.TimeoutExpired:
            logger.error(f"Vivado script timed out after {timeout}s")
            return VivadoResult(False, "", "Script timed out", -1, 0)
        except Exception as e:
            logger.error(f"Error executing Vivado script: {e}")
            return VivadoResult(False, "", str(e), -1, 0)
        finally:
            # Clean up temporary file
            if isinstance(script, TCLScript):
                try:
                    os.unlink(script_path)
                except:
                    pass
    
    async def run_command_async(self, tcl_command: str, 
                               mode: VivadoMode = VivadoMode.BATCH,
                               timeout: Optional[int] = None) -> VivadoResult:
        """Run a TCL command asynchronously"""
        import time
        start_time = time.time()
        
        try:
            # Prepare command
            cmd_args = [self.vivado_path]
            
            if mode == VivadoMode.BATCH:
                cmd_args.extend(['-mode', 'batch'])
            elif mode == VivadoMode.TCL:
                cmd_args.extend(['-mode', 'tcl'])
            
            cmd_args.extend(['-source', '-'])
            
            # Execute command asynchronously
            process = await asyncio.create_subprocess_exec(
                *cmd_args,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.working_dir
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(input=tcl_command.encode()),
                timeout=timeout
            )
            
            execution_time = time.time() - start_time
            
            return VivadoResult(
                success=process.returncode == 0,
                stdout=stdout.decode(),
                stderr=stderr.decode(),
                return_code=process.returncode,
                execution_time=execution_time
            )
            
        except asyncio.TimeoutError:
            logger.error(f"Vivado async command timed out after {timeout}s")
            return VivadoResult(False, "", "Command timed out", -1, time.time() - start_time)
        except Exception as e:
            logger.error(f"Error executing Vivado async command: {e}")
            return VivadoResult(False, "", str(e), -1, time.time() - start_time)
    
    def create_project_script(self, project_name: str, 
                            rtl_files: List[str],
                            testbench_files: List[str],
                            target_part: str = "xc7a35tcpg236-1") -> TCLScript:
        """Create a TCL script for project setup"""
        script = TCLScript(f"create_project_{project_name}")
        
        # Set variables
        script.add_variable("project_name", project_name)
        script.add_variable("target_part", target_part)
        
        # Create project
        script.add_command(
            "create_project $project_name . -part $target_part -force",
            "Create new Vivado project"
        )
        
        # Add RTL files
        for rtl_file in rtl_files:
            script.add_command(
                f"add_files \"{rtl_file}\"",
                f"Add RTL file: {Path(rtl_file).name}"
            )
        
        # Add testbench files
        for tb_file in testbench_files:
            script.add_command(
                f"add_files -fileset sim_1 \"{tb_file}\"",
                f"Add testbench file: {Path(tb_file).name}"
            )
        
        # Set top module for simulation (assume first testbench file)
        if testbench_files:
            tb_top = Path(testbench_files[0]).stem
            script.add_command(
                f"set_property top {tb_top} [get_filesets sim_1]",
                "Set simulation top module"
            )
        
        return script
    
    def create_simulation_script(self, project_name: str,
                               simulation_time: str = "1000ns") -> TCLScript:
        """Create a TCL script for running simulation"""
        script = TCLScript(f"run_simulation_{project_name}")
        
        # Set variables
        script.add_variable("project_name", project_name)
        script.add_variable("sim_time", simulation_time)
        
        # Open project
        script.add_command(
            "open_project $project_name.xpr",
            "Open Vivado project"
        )
        
        # Launch simulation
        script.add_command(
            "launch_simulation",
            "Launch behavioral simulation"
        )
        
        # Run simulation
        script.add_command(
            "run $sim_time",
            f"Run simulation for {simulation_time}"
        )
        
        # Save waveform
        script.add_command(
            "save_wave_config simulation.wcfg",
            "Save waveform configuration"
        )
        
        # Close simulation
        script.add_command(
            "close_sim",
            "Close simulation"
        )
        
        return script
    
    def parse_log_file(self, log_file: Union[str, Path]) -> Dict[str, any]:
        """Parse Vivado log file for errors, warnings, and other information"""
        log_path = Path(log_file)
        if not log_path.exists():
            return {"error": f"Log file not found: {log_path}"}
        
        try:
            with open(log_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parse log content
            errors = re.findall(r'ERROR:.*', content, re.MULTILINE)
            warnings = re.findall(r'WARNING:.*', content, re.MULTILINE)
            critical_warnings = re.findall(r'CRITICAL WARNING:.*', content, re.MULTILINE)
            
            # Extract timing information
            timing_matches = re.findall(r'Finished.*in\s+([\d.]+)\s*seconds', content)
            
            return {
                "errors": errors,
                "warnings": warnings,
                "critical_warnings": critical_warnings,
                "timing": timing_matches,
                "total_lines": len(content.splitlines()),
                "success": len(errors) == 0
            }
            
        except Exception as e:
            logger.error(f"Failed to parse log file {log_path}: {e}")
            return {"error": str(e)}
    
    def get_version(self) -> Optional[str]:
        """Get Vivado version"""
        try:
            result = self.run_command("version", timeout=30)
            if result.success:
                # Extract version from output
                version_match = re.search(r'Vivado\s+v([\d.]+)', result.stdout)
                if version_match:
                    return version_match.group(1)
            return None
        except Exception as e:
            logger.error(f"Failed to get Vivado version: {e}")
            return None
